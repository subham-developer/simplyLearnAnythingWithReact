{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar PUNCTUATION_LIST = [\".\", \",\", \"!\", \"?\", \"'\", \"{\", \"}\", \"(\", \")\", \"[\", \"]\", \"/\"];\n\nvar trimText = function trimText(text) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 80;\n  var ideal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n  var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 200; //This main function uses two pointers to move out from the ideal, to find the first instance of a punctuation mark followed by a space. If one cannot be found, it will go with the first space closest to the ideal.\n\n  if (max < min || ideal > max || ideal < min) {\n    throw new Error(\"The minimum length must be less than the maximum, and the ideal must be between the minimum and maximum.\");\n  }\n\n  if (text.length < ideal) {\n    return [text, ''];\n  }\n\n  var pointerOne = ideal;\n  var pointerTwo = ideal;\n  var firstSpace = void 0,\n      resultIdx = void 0;\n\n  var setSpace = function setSpace(idx) {\n    if (spaceMatch(text[idx])) {\n      firstSpace = firstSpace || idx;\n    }\n  };\n\n  while (pointerOne < max || pointerTwo > min) {\n    if (checkMatch(pointerOne, text, max, min)) {\n      resultIdx = pointerOne + 1;\n      break;\n    } else if (checkMatch(pointerTwo, text, max, min)) {\n      resultIdx = pointerTwo + 1;\n      break;\n    } else {\n      setSpace(pointerOne);\n      setSpace(pointerTwo);\n    }\n\n    pointerOne++;\n    pointerTwo--;\n  }\n\n  if (resultIdx === undefined) {\n    if (firstSpace && firstSpace >= min && firstSpace <= max) {\n      resultIdx = firstSpace;\n    } else if (ideal - min < max - ideal) {\n      resultIdx = min;\n    } else {\n      resultIdx = max;\n    }\n  }\n\n  return [text.slice(0, resultIdx), text.slice(resultIdx).trim()];\n};\n\nvar spaceMatch = function spaceMatch(character) {\n  if (character === \" \") {\n    return true;\n  }\n};\n\nvar punctuationMatch = function punctuationMatch(idx, text) {\n  var punctuationIdx = PUNCTUATION_LIST.indexOf(text[idx]);\n\n  if (punctuationIdx >= 0 && spaceMatch(text[idx + 1])) {\n    return true;\n  }\n};\n\nvar checkMatch = function checkMatch(idx, text, max, min) {\n  if (idx < max && idx > min && punctuationMatch(idx, text)) {\n    return true;\n  }\n};\n\nexports.default = trimText;","map":{"version":3,"sources":["/Users/shubhamlal/DevelopmentCodes/simplylearnanythingReact/simplylearn/node_modules/read-more-react/dist/utils/trimText.js"],"names":["Object","defineProperty","exports","value","PUNCTUATION_LIST","trimText","text","min","arguments","length","undefined","ideal","max","Error","pointerOne","pointerTwo","firstSpace","resultIdx","setSpace","idx","spaceMatch","checkMatch","slice","trim","character","punctuationMatch","punctuationIdx","indexOf","default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nvar PUNCTUATION_LIST = [\".\", \",\", \"!\", \"?\", \"'\", \"{\", \"}\", \"(\", \")\", \"[\", \"]\", \"/\"];\n\nvar trimText = function trimText(text) {\n\tvar min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 80;\n\tvar ideal = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n\tvar max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 200;\n\n\t//This main function uses two pointers to move out from the ideal, to find the first instance of a punctuation mark followed by a space. If one cannot be found, it will go with the first space closest to the ideal.\n\n\tif (max < min || ideal > max || ideal < min) {\n\t\tthrow new Error(\"The minimum length must be less than the maximum, and the ideal must be between the minimum and maximum.\");\n\t}\n\n\tif (text.length < ideal) {\n\t\treturn [text, ''];\n\t}\n\n\tvar pointerOne = ideal;\n\tvar pointerTwo = ideal;\n\tvar firstSpace = void 0,\n\t    resultIdx = void 0;\n\n\tvar setSpace = function setSpace(idx) {\n\t\tif (spaceMatch(text[idx])) {\n\t\t\tfirstSpace = firstSpace || idx;\n\t\t}\n\t};\n\n\twhile (pointerOne < max || pointerTwo > min) {\n\t\tif (checkMatch(pointerOne, text, max, min)) {\n\t\t\tresultIdx = pointerOne + 1;\n\t\t\tbreak;\n\t\t} else if (checkMatch(pointerTwo, text, max, min)) {\n\t\t\tresultIdx = pointerTwo + 1;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tsetSpace(pointerOne);\n\t\t\tsetSpace(pointerTwo);\n\t\t}\n\n\t\tpointerOne++;\n\t\tpointerTwo--;\n\t}\n\n\tif (resultIdx === undefined) {\n\t\tif (firstSpace && firstSpace >= min && firstSpace <= max) {\n\t\t\tresultIdx = firstSpace;\n\t\t} else if (ideal - min < max - ideal) {\n\t\t\tresultIdx = min;\n\t\t} else {\n\t\t\tresultIdx = max;\n\t\t}\n\t}\n\n\treturn [text.slice(0, resultIdx), text.slice(resultIdx).trim()];\n};\n\nvar spaceMatch = function spaceMatch(character) {\n\tif (character === \" \") {\n\t\treturn true;\n\t}\n};\n\nvar punctuationMatch = function punctuationMatch(idx, text) {\n\tvar punctuationIdx = PUNCTUATION_LIST.indexOf(text[idx]);\n\tif (punctuationIdx >= 0 && spaceMatch(text[idx + 1])) {\n\t\treturn true;\n\t}\n};\n\nvar checkMatch = function checkMatch(idx, text, max, min) {\n\tif (idx < max && idx > min && punctuationMatch(idx, text)) {\n\t\treturn true;\n\t}\n};\n\nexports.default = trimText;"]},"metadata":{},"sourceType":"script"}